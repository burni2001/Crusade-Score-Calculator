<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Adeptus Astartes - Mission Debrief</title>
        <link rel="manifest" href="manifest.json" />
        <meta name="theme-color" content="#050a05" />
        <!-- Matches background_color from manifest -->
        <style>
            @import url("https://fonts.googleapis.com/css2?family=VT323&display=swap");

            :root {
                --pip-green: #33ff00;
                --pip-dim: #1a8000;
                --bg-color: #050a05;
                --panel-bg: #0c140c;
                --border-color: #1f3a1f;
            }
            body {
                background-color: #000;
                color: var(--pip-green);
                font-family: "VT323", monospace;
                margin: 0;
                padding: 20px;
                display: flex;
                justify-content: center;
                min-height: 100vh;
                background-image: repeating-linear-gradient(
                    0deg,
                    rgba(0, 0, 0, 0.15),
                    rgba(0, 0, 0, 0.15) 1px,
                    transparent 1px,
                    transparent 2px
                );
            }
            /* CRT Screen Effect */
            .cogitator-frame {
                width: 100%;
                max-width: 1100px;
                background-color: var(--bg-color);
                border: 4px solid #3d4c3d;
                box-shadow:
                    0 0 20px rgba(51, 255, 0, 0.2),
                    inset 0 0 50px rgba(0, 0, 0, 0.8);
                padding: 20px;
                position: relative;
            }
            .cogitator-frame::before {
                content: " ";
                display: block;
                position: absolute;
                top: 0;
                left: 0;
                bottom: 0;
                right: 0;
                background:
                    linear-gradient(
                        rgba(18, 16, 16, 0) 50%,
                        rgba(0, 0, 0, 0.25) 50%
                    ),
                    linear-gradient(
                        90deg,
                        rgba(255, 0, 0, 0.06),
                        rgba(0, 255, 0, 0.02),
                        rgba(0, 0, 255, 0.06)
                    );
                z-index: 2;
                background-size:
                    100% 2px,
                    3px 100%;
                pointer-events: none;
            }
            h1,
            h2,
            h3 {
                text-transform: uppercase;
                text-align: center;
                margin: 5px 0;
                text-shadow: 0 0 5px var(--pip-green);
                letter-spacing: 2px;
            }

            .header-decor {
                border-bottom: 2px solid var(--pip-green);
                margin-bottom: 20px;
                padding-bottom: 10px;
                display: flex;
                justify-content: space-between;
                align-items: flex-end;
            }
            /* Inputs and Selects Styling */
            input,
            select {
                background-color: #000;
                color: var(--pip-green);
                border: 1px solid var(--pip-green);
                font-family: "VT323", monospace;
                font-size: 1.2rem;
                text-align: center;
                padding: 2px;
                width: 100%;
                box-sizing: border-box;
            }
            input:focus,
            select:focus {
                outline: none;
                box-shadow: 0 0 8px var(--pip-green);
                background-color: #0f240f;
            }

            /* Layout Sections */
            .section {
                background-color: rgba(20, 40, 20, 0.3);
                border: 1px solid var(--border-color);
                padding: 15px;
                margin-bottom: 20px;
            }

            /* Modifier Grid */
            .modifier-grid {
                display: grid;
                grid-template-columns: 100px repeat(7, 1fr);
                gap: 10px;
                align-items: center;
                text-align: center;
                font-size: 1.1rem;
            }

            .modifier-grid label {
                font-size: 0.9rem;
                opacity: 0.8;
            }
            /* Global Toggles (Dropdowns) styling inside .section */
            /* To make labels and selects align */
            .mission-params {
                display: grid;
                /* Fixed width for label column for alignment.
               minmax ensures input has at least 140px, then takes 1fr. */
                grid-template-columns: 160px minmax(140px, 1fr);
                gap: 10px;
                margin-bottom: 10px;
                align-items: center; /* Vertically align label and select */
                font-size: 1.1rem;
            }
            /* Ensure labels wrap if they are longer than the fixed column width */
            .mission-params label {
                word-wrap: break-word; /* For older browsers */
                overflow-wrap: break-word; /* Standard property for breaking words */
            }

            /* NEW: Container for Dropdowns and Description (side-by-side) */
            .mission-info-area {
                display: grid;
                grid-template-columns: 1fr 2fr; /* Dropdowns (smaller) and Description (larger) */
                gap: 20px; /* Space between the two columns */
                margin-bottom: 20px;
            }

            /* NEW: Styling for the description text area */
            .app-description {
                background-color: rgba(20, 40, 20, 0.3);
                border: 1px solid var(--border-color);
                padding: 15px;
                line-height: 1.5; /* Readability */
                font-size: 1.1rem;
                text-align: left;
                overflow-y: auto; /* In case text is too long */
            }

            /* Main Score Table */
            .score-table {
                width: 100%;
                border-collapse: separate;
                border-spacing: 5px;
            }

            .score-table th {
                text-align: center;
                padding: 10px;
                background-color: #000;
                border: 1px solid var(--pip-dim);
            }
            /* Specific style for empty header to remove it visually */
            .score-table th.empty-header {
                background-color: transparent;
                border: none;
                box-shadow: none;
            }

            .score-table td {
                padding: 4px;
                vertical-align: middle;
                border: 1px solid var(--border-color); /* Add border to cells */
                background-color: var(--panel-bg); /* Add background to cells */
            }

            .row-label {
                text-align: right;
                padding-right: 15px !important;
                font-weight: bold;
                width: 180px; /* Fixed width for labels */
                background-color: #000; /* Darker background for labels */
            }
            .input-cell {
                width: 120px; /* Fixed width for input cells */
            }

            .total-cell {
                width: 120px; /* Fixed width for total cells */
                text-align: center;
                font-weight: bold;
                background-color: #000; /* Darker background for totals */
            }
            .section-header {
                background-color: #000;
                color: var(--pip-green);
                padding: 5px;
                font-weight: bold;
                text-align: center;
                margin-bottom: 15px;
                border: 1px solid var(--pip-green);
            }
            /* Specific Rows styling based on screenshot logic */
            .base-score-row td,
            .mod-score-row td {
                font-weight: bold;
                text-align: center;
            }
            /* Keep row labels right-aligned for score rows */
            .base-score-row td.row-label,
            .mod-score-row td.row-label {
                text-align: right !important;
            }
            .final-score-row td {
                border-top: 2px solid var(--pip-green);
                border-bottom: 2px double var(--pip-green);
                font-size: 1.5rem;
                font-weight: bold;
                color: #afffa6; /* Brighter green */
                text-align: center;
                padding: 15px 0;
                text-shadow: 0 0 8px var(--pip-green);
            }
            /* Chrome styling for number inputs (hide spinners) */
            input::-webkit-outer-spin-button,
            input::-webkit-inner-spin-button {
                -webkit-appearance: none;
                margin: 0;
            }
            input[type="number"] {
                -moz-appearance: textfield;
            }

            /* Ensure input and select fields have matching width */
            .mission-params input[type="number"],
            .mission-params select {
                width: 100%;
                box-sizing: border-box;
            }

            /* Styling for selected options in dropdowns */
            select option {
                background-color: #000; /* Dark background for dropdown options */
                color: #0f0; /* Green text for options */
            }
            /* Style for disabled/hidden placeholder option */
            select option[disabled][selected][hidden] {
                color: rgba(0, 255, 0, 0.5); /* Lighter green for placeholder */
            }
            /* Export Buttons Container */
            .export-buttons-container {
                display: flex;
                flex-wrap: wrap; /* Allow buttons to wrap on smaller screens */
                justify-content: center;
                gap: 20px;
                margin-top: 25px;
                padding-top: 15px;
                border-top: 1px solid var(--border-color);
            }

            .export-buttons-container button {
                background-color: var(--panel-bg);
                color: var(--pip-green);
                border: 1px solid var(--pip-green);
                padding: 10px 20px;
                font-family: "VT323", monospace;
                font-size: 1.1rem;
                cursor: pointer;
                text-transform: uppercase;
                letter-spacing: 1px;
                transition: all 0.2s ease-in-out;
                box-shadow: 0 0 5px rgba(51, 255, 0, 0.2);
                flex: 1 1 auto; /* Allow buttons to grow/shrink, maintain aspect */
                min-width: 180px; /* Minimum width before wrapping */
            }

            .export-buttons-container button:hover {
                background-color: var(--pip-green);
                color: var(--bg-color);
                box-shadow: 0 0 15px var(--pip-green);
            }

            .export-buttons-container button.danger-btn {
                border-color: #ff6600;
                color: #ff6600;
            }

            .export-buttons-container button.danger-btn:hover {
                background-color: #ff6600;
                color: var(--bg-color);
                box-shadow: 0 0 15px #ff6600;
            }

            /* OCR Review Modal */
            .ocr-modal-overlay {
                display: none;
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background-color: rgba(0, 0, 0, 0.9);
                z-index: 1000;
                justify-content: center;
                align-items: center;
                padding: 20px;
            }

            .ocr-modal-overlay.active {
                display: flex;
            }

            .ocr-modal {
                background-color: var(--bg-color);
                border: 2px solid var(--pip-green);
                box-shadow: 0 0 30px rgba(51, 255, 0, 0.3);
                max-width: 800px;
                width: 100%;
                max-height: 90vh;
                overflow-y: auto;
                padding: 20px;
            }

            .ocr-modal h2 {
                margin-top: 0;
                border-bottom: 1px solid var(--pip-green);
                padding-bottom: 10px;
            }

            .ocr-modal-section {
                margin-bottom: 20px;
            }

            .ocr-modal-section h3 {
                font-size: 1.1rem;
                margin-bottom: 10px;
                color: var(--pip-dim);
            }

            .ocr-raw-text {
                background-color: #000;
                border: 1px solid var(--border-color);
                padding: 10px;
                max-height: 150px;
                overflow-y: auto;
                font-size: 0.9rem;
                white-space: pre-wrap;
                word-break: break-word;
            }

            .ocr-detected-grid {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 10px;
            }

            .ocr-detected-item {
                display: flex;
                justify-content: space-between;
                align-items: center;
                background-color: rgba(51, 255, 0, 0.1);
                padding: 8px 12px;
                border: 1px solid var(--border-color);
            }

            .ocr-detected-item.not-found {
                background-color: rgba(255, 100, 0, 0.1);
                border-color: #ff6600;
            }

            .ocr-detected-label {
                font-weight: bold;
            }

            .ocr-detected-value {
                color: #afffa6;
            }

            .ocr-detected-value.missing {
                color: #ff6600;
                font-style: italic;
            }

            .ocr-input {
                background-color: #0a1f0a;
                border: 1px solid var(--border-color);
                color: #afffa6;
                font-family: "VT323", monospace;
                font-size: 16px;
                padding: 4px 8px;
                width: 140px;
            }

            .ocr-input:focus {
                outline: none;
                border-color: #afffa6;
                box-shadow: 0 0 5px rgba(175, 255, 166, 0.3);
            }

            .ocr-input::placeholder {
                color: #666;
                font-style: italic;
            }

            .ocr-select {
                cursor: pointer;
            }

            .ocr-input[type="number"] {
                width: 80px;
            }

            .ocr-section {
                background-color: rgba(0, 40, 0, 0.3);
                border: 1px solid var(--border-color);
                border-radius: 4px;
                padding: 10px;
                margin-bottom: 10px;
            }

            .ocr-section-title {
                color: #afffa6;
                font-size: 18px;
                font-weight: bold;
                margin-bottom: 8px;
                padding-bottom: 5px;
                border-bottom: 1px solid var(--border-color);
            }

            .ocr-player-section .ocr-detected-item {
                margin-bottom: 5px;
            }

            .ocr-stats-row {
                display: grid;
                grid-template-columns: repeat(4, 1fr);
                gap: 8px;
                margin-top: 8px;
            }

            .ocr-stats-row .ocr-detected-item {
                flex-direction: column;
                align-items: flex-start;
                gap: 2px;
            }

            .ocr-stats-row .ocr-detected-label {
                font-size: 12px;
            }

            .ocr-stats-row .ocr-input[type="number"] {
                width: 100%;
            }

            .ocr-modal-buttons {
                display: flex;
                gap: 15px;
                justify-content: center;
                margin-top: 20px;
                padding-top: 15px;
                border-top: 1px solid var(--border-color);
            }

            .ocr-modal-buttons button {
                background-color: var(--panel-bg);
                color: var(--pip-green);
                border: 1px solid var(--pip-green);
                padding: 10px 25px;
                font-family: "VT323", monospace;
                font-size: 1.1rem;
                cursor: pointer;
                text-transform: uppercase;
            }

            .ocr-modal-buttons button:hover {
                background-color: var(--pip-green);
                color: var(--bg-color);
            }

            .ocr-modal-buttons button.cancel-btn {
                border-color: #ff6600;
                color: #ff6600;
            }

            .ocr-modal-buttons button.cancel-btn:hover {
                background-color: #ff6600;
                color: var(--bg-color);
            }

            @media (max-width: 768px) {
                .ocr-detected-grid {
                    grid-template-columns: 1fr;
                }
            }

            /* --- Responsive Design Adjustments --- */
            @media (max-width: 768px) {
                body {
                    padding: 10px; /* Reduce overall padding */
                }
                .cogitator-frame {
                    padding: 10px; /* Reduce frame padding */
                    border-width: 2px; /* Thinner border */
                    box-shadow:
                        0 0 10px rgba(51, 255, 0, 0.2),
                        inset 0 0 25px rgba(0, 0, 0, 0.8);
                }

                .header-decor {
                    flex-direction: column; /* Stack items vertically */
                    align-items: center; /* Center items */
                    text-align: center;
                    margin-bottom: 10px;
                }
                .header-decor > div {
                    margin-bottom: 5px; /* Add some space between stacked header elements */
                }

                h1 {
                    font-size: 1.5em; /* Smaller mission debrief title */
                }

                input,
                select {
                    font-size: 1rem; /* Smaller font size for inputs/selects */
                    padding: 1px;
                }

                .section {
                    padding: 10px; /* Reduce section padding */
                    margin-bottom: 15px; /* Adjust margin */
                }
                /* Modifiers Grid */
                .modifier-grid {
                    /* Auto-fit items into available space, minimum 100px. Can result in 2 or 3 columns depending on screen. */
                    grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
                    gap: 5px; /* Reduce gap */
                }
                /* Make the 'MODIFIERS' label span all columns and center it */
                .modifier-grid div:first-child {
                    grid-column: 1 / -1;
                    text-align: center !important;
                    margin-bottom: 5px;
                }

                /* Mission Info Area (Dropdowns + Description) */
                .mission-info-area {
                    grid-template-columns: 1fr; /* Stack dropdowns and description vertically */
                    gap: 15px; /* Space between stacked sections */
                }
                .mission-info-area .section {
                    margin-bottom: 0; /* No extra margin for the inner section */
                }

                /* Mission Params (individual dropdowns) */
                .mission-params {
                    grid-template-columns: 1fr; /* Stack label and select vertically */
                    gap: 2px; /* Reduce gap */
                    margin-bottom: 8px; /* Reduce margin */
                    font-size: 1rem;
                }
                .mission-params label {
                    text-align: left; /* Align labels left when stacked */
                    margin-bottom: 2px;
                    /* On small screens (stacked), labels will naturally take full width, so word-wrap isn't strictly needed here but doesn't hurt */
                }

                /* App Description */
                .app-description {
                    font-size: 1rem;
                }

                /* Score Table - Make scrollable on small screens */
                .score-table-container {
                    overflow-x: auto;
                }

                /* Export buttons */
                .export-buttons-container {
                    flex-direction: column;
                    gap: 10px;
                }
                .export-buttons-container button {
                    width: 100%;
                    font-size: 1rem;
                    padding: 8px 15px;
                }
            }
            /* Further adjustments for very small screens (e.g., typical smartphone portrait) */
            @media (max-width: 480px) {
                .modifier-grid {
                    grid-template-columns: 1fr; /* Stack all modifiers vertically */
                }
                .modifier-grid div:first-child {
                    /* The 'MODIFIERS' label */
                    grid-column: auto; /* Reset grid-column to normal flow */
                }
            }
        </style>
    </head>
    <body>
        <div class="cogitator-frame">
            <div class="header-decor">
                <div>
                    <div>REF: SM-2/CRUSADE</div>
                    <div style="font-size: 0.8em; opacity: 0.7">
                        V 0.9.7 - ADEPTUS ADMINISTRATUM
                    </div>
                </div>
                <h1>Mission Debrief</h1>
                <div>DAT: M42.024</div>
            </div>
            <!-- Modifiers Section -->
            <div class="section">
                <div class="modifier-grid">
                    <div style="text-align: left; font-weight: bold">
                        MODIFIERS
                    </div>

                    <div>
                        <label>Kills</label>
                        <input
                            type="number"
                            id="mod-kills"
                            value="1"
                            inputmode="numeric"
                            onchange="calculate(); saveData();"
                        />
                    </div>
                    <div>
                        <label>Special Kills</label>
                        <input
                            type="number"
                            id="mod-elite"
                            value="20"
                            inputmode="numeric"
                            onchange="calculate(); saveData();"
                        />
                    </div>
                    <div>
                        <label>Incapacitations</label>
                        <input
                            type="number"
                            id="mod-death"
                            value="-100"
                            inputmode="numeric"
                            onchange="calculate(); saveData();"
                        />
                    </div>
                    <div>
                        <label>Damage Taken</label>
                        <input
                            type="number"
                            id="mod-damage"
                            value="-0.1"
                            step="0.1"
                            inputmode="decimal"
                            onchange="calculate(); saveData();"
                        />
                    </div>
                    <div>
                        <label>Gene-Seed</label>
                        <input
                            type="number"
                            id="mod-gene"
                            value="100"
                            inputmode="numeric"
                            onchange="calculate(); saveData();"
                        />
                    </div>
                    <div>
                        <label>Armoury Data</label>
                        <input
                            type="number"
                            id="mod-armoury"
                            value="25"
                            inputmode="numeric"
                            onchange="calculate(); saveData();"
                        />
                    </div>
                    <div>
                        <label>Objective</label>
                        <input
                            type="number"
                            id="mod-obj"
                            value="100"
                            inputmode="numeric"
                            onchange="calculate(); saveData();"
                        />
                    </div>
                </div>
            </div>
            <!-- NEW: Mission Info Area: Dropdowns (left) and Description (right) -->
            <div class="mission-info-area">
                <!-- Global Toggles Section (your dropdowns) -->
                <div class="section" style="margin-bottom: 0">
                    <!-- Remove bottom margin as parent handles spacing -->
                    <!-- Screenshot Upload Section -->
                    <div
                        style="
                            margin-bottom: 15px;
                            padding: 10px;
                            background-color: rgba(51, 255, 0, 0.1);
                            border: 1px solid var(--pip-green);
                        "
                    >
                        <label
                            for="screenshot-upload"
                            style="
                                display: block;
                                margin-bottom: 8px;
                                font-weight: bold;
                                text-align: center;
                            "
                        >
                            UPLOAD SCREENSHOTS
                        </label>
                        <p
                            style="
                                font-size: 0.85em;
                                color: #7a7;
                                margin: 5px 0 10px 0;
                                text-align: center;
                            "
                        >
                            Upload your post-mission screenshots. Select
                            multiple player stat screens for best results.
                            Review and edit detected values before applying.
                        </p>
                        <input
                            type="file"
                            id="screenshot-upload"
                            accept="image/png,image/jpeg,image/jpg"
                            multiple
                            style="
                                display: block;
                                margin: 0 auto;
                                padding: 8px;
                                background-color: var(--panel-bg);
                                cursor: pointer;
                            "
                        />
                        <div
                            id="upload-status"
                            style="
                                margin-top: 10px;
                                text-align: center;
                                font-size: 0.9rem;
                                min-height: 20px;
                            "
                        ></div>
                        <div
                            id="upload-progress"
                            style="
                                margin-top: 5px;
                                text-align: center;
                                font-size: 0.85rem;
                                color: var(--pip-dim);
                            "
                        ></div>
                    </div>
                    <!-- NEW: Mission Played input field -->
                    <div class="mission-params">
                        <label for="mission-name">Mission Played</label>
                        <input
                            type="text"
                            id="mission-name"
                            value=""
                            placeholder="e.g., Inferno"
                            onchange="saveData();"
                        />
                    </div>
                    <div class="mission-params">
                        <label for="mission-difficulty">Difficulty</label>
                        <select
                            id="mission-difficulty"
                            onchange="calculate(); saveData();"
                        >
                            <option value="" disabled selected hidden>
                                Select Difficulty
                            </option>
                            <option value="Minimal">Minimal</option>
                            <option value="Average">Average</option>
                            <option value="Substantial">Substantial</option>
                            <option value="Ruthless">Ruthless</option>
                            <option value="Lethal">Lethal</option>
                            <option value="Absolute">Absolute</option>
                            <option value="Normal">Normal</option>
                            <option value="Hard">Hard</option>
                        </select>
                    </div>
                    <div class="mission-params">
                        <label>Objective Completion</label>
                        <select
                            id="global-objective"
                            onchange="calculate(); saveData();"
                        >
                            <option value="" disabled selected hidden>
                                Select
                            </option>
                            <option value="0">No</option>
                            <option value="1">Yes</option>
                        </select>
                    </div>
                    <div class="mission-params">
                        <label>Gene-Seed Retrieved</label>
                        <select
                            id="global-geneseed"
                            onchange="calculate(); saveData();"
                        >
                            <option value="" disabled selected hidden>
                                Select
                            </option>
                            <option value="0">No</option>
                            <option value="1">Yes</option>
                        </select>
                    </div>
                    <div class="mission-params">
                        <label>Armoury Data Retrieved</label>
                        <select
                            id="global-armoury"
                            onchange="calculate(); saveData();"
                        >
                            <option value="" disabled selected hidden>
                                Select
                            </option>
                            <option value="0">0</option>
                            <option value="1">1</option>
                            <option value="2">2</option>
                            <option value="3">3</option>
                        </select>
                    </div>
                    <div class="mission-params">
                        <label>Waves Reached (Siege Mode)</label>
                        <input
                            type="number"
                            id="global-waves"
                            value="0"
                            min="0"
                            inputmode="numeric"
                            onchange="saveData();"
                            placeholder="e.g., 15"
                        />
                    </div>
                </div>
                <!-- THIS IS WHERE YOU WRITE YOUR DESCRIPTION TEXT! -->
                <div class="app-description">
                    Welcome, Brothers and Sisters! Use this debriefing tool to
                    calculate your mission scores. Select the Mission
                    parameters. Enter your mission statistics (Kills,
                    Incapacitations, etc.) below. The Modifier section allows
                    customization of score values if necessary. Ensure all
                    fields are filled for an accurate debrief.
                    <br /><br />
                    *Glory to the Imperium!*
                </div>
            </div>
            <!-- Main Data Table (Squad Performance Matrix) -->
            <div class="section" style="margin-bottom: 0">
                <!-- Last section, no bottom margin -->
                <div class="section-header">SQUAD PERFORMANCE MATRIX</div>
                <div class="score-table-container">
                    <!-- ADD THIS WRAPPER -->
                    <table class="score-table">
                        <thead>
                            <tr>
                                <th class="empty-header"></th>
                                <th>
                                    <input
                                        type="text"
                                        value=""
                                        placeholder="Name"
                                        class="player-name-input"
                                        id="p1-name"
                                        onchange="saveData();"
                                    />
                                </th>
                                <th>
                                    <input
                                        type="text"
                                        value=""
                                        placeholder="Name"
                                        class="player-name-input"
                                        id="p2-name"
                                        onchange="saveData();"
                                    />
                                </th>
                                <th>
                                    <input
                                        type="text"
                                        value=""
                                        placeholder="Name"
                                        class="player-name-input"
                                        id="p3-name"
                                        onchange="saveData();"
                                    />
                                </th>
                                <th>TOTAL</th>
                            </tr>
                        </thead>
                        <tbody>
                            <!-- Class -->
                            <tr>
                                <td class="row-label">Class</td>
                                <td class="input-cell">
                                    <select
                                        id="p1-class"
                                        onchange="saveData();"
                                    >
                                        <option value="">-</option>
                                        <option value="Tactical">
                                            Tactical
                                        </option>
                                        <option value="Assault">Assault</option>
                                        <option value="Vanguard">
                                            Vanguard
                                        </option>
                                        <option value="Bulwark">Bulwark</option>
                                        <option value="Sniper">Sniper</option>
                                        <option value="Heavy">Heavy</option>
                                        <option value="Techmarine">
                                            Techmarine
                                        </option>
                                    </select>
                                </td>
                                <td class="input-cell">
                                    <select
                                        id="p2-class"
                                        onchange="saveData();"
                                    >
                                        <option value="">-</option>
                                        <option value="Tactical">
                                            Tactical
                                        </option>
                                        <option value="Assault">Assault</option>
                                        <option value="Vanguard">
                                            Vanguard
                                        </option>
                                        <option value="Bulwark">Bulwark</option>
                                        <option value="Sniper">Sniper</option>
                                        <option value="Heavy">Heavy</option>
                                        <option value="Techmarine">
                                            Techmarine
                                        </option>
                                    </select>
                                </td>
                                <td class="input-cell">
                                    <select
                                        id="p3-class"
                                        onchange="saveData();"
                                    >
                                        <option value="">-</option>
                                        <option value="Tactical">
                                            Tactical
                                        </option>
                                        <option value="Assault">Assault</option>
                                        <option value="Vanguard">
                                            Vanguard
                                        </option>
                                        <option value="Bulwark">Bulwark</option>
                                        <option value="Sniper">Sniper</option>
                                        <option value="Heavy">Heavy</option>
                                        <option value="Techmarine">
                                            Techmarine
                                        </option>
                                    </select>
                                </td>
                                <td class="total-cell"></td>
                            </tr>
                            <!-- Kills -->
                            <tr>
                                <td class="row-label">Kills</td>
                                <td class="input-cell">
                                    <input
                                        type="number"
                                        class="p1-input"
                                        id="p1-kills"
                                        value="0"
                                        min="0"
                                        inputmode="numeric"
                                        onchange="calculate(); saveData();"
                                    />
                                </td>
                                <td class="input-cell">
                                    <input
                                        type="number"
                                        class="p2-input"
                                        id="p2-kills"
                                        value="0"
                                        min="0"
                                        inputmode="numeric"
                                        onchange="calculate(); saveData();"
                                    />
                                </td>
                                <td class="input-cell">
                                    <input
                                        type="number"
                                        class="p3-input"
                                        id="p3-kills"
                                        value="0"
                                        min="0"
                                        inputmode="numeric"
                                        onchange="calculate(); saveData();"
                                    />
                                </td>
                                <td class="total-cell" id="total-kills">0</td>
                            </tr>
                            <!-- Special Kills -->
                            <tr>
                                <td class="row-label">Special Kills</td>
                                <td class="input-cell">
                                    <input
                                        type="number"
                                        class="p1-input"
                                        id="p1-elite"
                                        value="0"
                                        min="0"
                                        inputmode="numeric"
                                        onchange="calculate(); saveData();"
                                    />
                                </td>
                                <td class="input-cell">
                                    <input
                                        type="number"
                                        class="p2-input"
                                        id="p2-elite"
                                        value="0"
                                        min="0"
                                        inputmode="numeric"
                                        onchange="calculate(); saveData();"
                                    />
                                </td>
                                <td class="input-cell">
                                    <input
                                        type="number"
                                        class="p3-input"
                                        id="p3-elite"
                                        value="0"
                                        min="0"
                                        inputmode="numeric"
                                        onchange="calculate(); saveData();"
                                    />
                                </td>
                                <td class="total-cell" id="total-elite">0</td>
                            </tr>
                            <!-- Base Score Result -->
                            <tr class="base-score-row">
                                <td class="row-label">Base Score</td>
                                <td id="p1-base">0</td>
                                <td id="p2-base">0</td>
                                <td id="p3-base">0</td>
                                <td id="total-base">0</td>
                            </tr>
                            <!-- Death -->
                            <tr>
                                <td class="row-label">Incapacitations</td>
                                <td class="input-cell">
                                    <input
                                        type="number"
                                        class="p1-input"
                                        id="p1-death"
                                        value="0"
                                        min="0"
                                        inputmode="numeric"
                                        onchange="calculate(); saveData();"
                                    />
                                </td>
                                <td class="input-cell">
                                    <input
                                        type="number"
                                        class="p2-input"
                                        id="p2-death"
                                        value="0"
                                        min="0"
                                        inputmode="numeric"
                                        onchange="calculate(); saveData();"
                                    />
                                </td>
                                <td class="input-cell">
                                    <input
                                        type="number"
                                        class="p3-input"
                                        id="p3-death"
                                        value="0"
                                        min="0"
                                        inputmode="numeric"
                                        onchange="calculate(); saveData();"
                                    />
                                </td>
                                <td class="total-cell" id="total-death">0</td>
                            </tr>
                            <!-- Damage -->
                            <tr>
                                <td class="row-label">Damage Taken</td>
                                <td class="input-cell">
                                    <input
                                        type="number"
                                        class="p1-input"
                                        id="p1-damage"
                                        value="0"
                                        min="0"
                                        step="0.1"
                                        inputmode="decimal"
                                        onchange="calculate(); saveData();"
                                    />
                                </td>
                                <td class="input-cell">
                                    <input
                                        type="number"
                                        class="p2-input"
                                        id="p2-damage"
                                        value="0"
                                        min="0"
                                        step="0.1"
                                        inputmode="decimal"
                                        onchange="calculate(); saveData();"
                                    />
                                </td>
                                <td class="input-cell">
                                    <input
                                        type="number"
                                        class="p3-input"
                                        id="p3-damage"
                                        value="0"
                                        min="0"
                                        step="0.1"
                                        inputmode="decimal"
                                        onchange="calculate(); saveData();"
                                    />
                                </td>
                                <td class="total-cell" id="total-damage">0</td>
                            </tr>

                            <!-- Modifier Score Result -->
                            <tr class="mod-score-row">
                                <td class="row-label">Modifier Score</td>
                                <td id="p1-mod">0</td>
                                <td id="p2-mod">0</td>
                                <td id="p3-mod">0</td>
                                <td id="total-mod">0</td>
                            </tr>
                            <!-- Spacer -->
                            <tr style="height: 10px"></tr>
                            <!-- TOTAL SCORE -->
                            <tr class="final-score-row">
                                <td class="row-label" style="color: #afffa6">
                                    TOTAL SCORE
                                </td>
                                <td id="p1-final">0</td>
                                <td id="p2-final">0</td>
                                <td id="p3-final">0</td>
                                <td id="total-final">0</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <!-- END OF WRAPPER -->
            </div>
            <!-- Export Buttons -->
            <div class="export-buttons-container">
                <button onclick="exportToCSV()">
                    Export to Data Slate (CSV)
                </button>
                <button onclick="saveAsPNG()">
                    Record Cogitator Display (PNG)
                </button>
                <button class="danger-btn" onclick="clearData()">
                    Clear Mission Data
                </button>
            </div>
        </div>

        <!-- OCR Review Modal -->
        <div id="ocr-modal-overlay" class="ocr-modal-overlay">
            <div class="ocr-modal">
                <h2>OCR Results Review</h2>

                <div class="ocr-modal-section">
                    <h3>Detected Values</h3>
                    <div id="ocr-detected-grid" class="ocr-detected-grid"></div>
                </div>

                <div class="ocr-modal-section">
                    <h3>Raw OCR Text (for manual review)</h3>
                    <div id="ocr-raw-text" class="ocr-raw-text"></div>
                </div>

                <div class="ocr-modal-buttons">
                    <button onclick="applyOCRResults()">Apply Values</button>
                    <button
                        onclick="exportOCRDebug()"
                        style="background: #335533"
                    >
                        Export Debug Data
                    </button>
                    <button class="cancel-btn" onclick="closeOCRModal()">
                        Cancel
                    </button>
                </div>
            </div>
        </div>

        <!-- html2canvas library for PNG export -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
        <!-- Tesseract.js for fallback OCR -->
        <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
        <!-- OCR powered by OCR.space API (with Tesseract fallback) -->
        <script>
            // Store OCR results for review
            let pendingOCRResults = {};
            let rawOCRText = "";

            // Screenshot Upload and OCR Processing
            document
                .getElementById("screenshot-upload")
                .addEventListener("change", async function (e) {
                    const files = e.target.files;
                    if (files.length === 0) return;

                    const statusDiv = document.getElementById("upload-status");
                    const progressDiv =
                        document.getElementById("upload-progress");

                    statusDiv.textContent = "Processing screenshots...";
                    statusDiv.style.color = "var(--pip-green)";

                    // Reset pending results
                    pendingOCRResults = {};
                    rawOCRText = "";

                    try {
                        for (let i = 0; i < files.length; i++) {
                            const file = files[i];
                            progressDiv.textContent = `Processing image ${i + 1} of ${files.length}...`;

                            await processScreenshot(
                                file,
                                statusDiv,
                                progressDiv,
                            );
                        }

                        // Parse combined OCR text from all screenshots
                        parseGameData(rawOCRText);

                        statusDiv.textContent =
                            "OCR complete - review results below";
                        statusDiv.style.color = "#afffa6";
                        progressDiv.textContent = "";

                        // Show the review modal
                        showOCRModal();

                        // Clear the file input for future uploads
                        e.target.value = "";
                    } catch (error) {
                        console.error("OCR Error:", error);
                        const errorMsg =
                            error.message ||
                            error.toString() ||
                            "Unknown error";
                        statusDiv.textContent = `Error: ${errorMsg}`;
                        statusDiv.style.color = "#ff3300";
                        progressDiv.textContent = "";
                    }
                });

            // OCR API key (base64 encoded for light obfuscation - not security)
            const _k = "Szg4MDc3MzI3NTg4OTU3";
            function getOCRKey() {
                return atob(_k);
            }

            // Split image into left and right halves for dual-pass OCR
            // Left half: uncropped (mission header)
            // Right half: upscaled (stats panel with numbers)
            async function splitImageForOCR(dataUrl, maxSizeKB = 900) {
                return new Promise((resolve) => {
                    const img = new Image();
                    img.onload = function () {
                        const origWidth = img.width;
                        const origHeight = img.height;

                        // Split point at 50% of image width
                        const splitX = Math.round(origWidth * 0.5);

                        // === LEFT HALF (for mission header) ===
                        // Keep at original size, just crop to left portion
                        const leftCanvas = document.createElement("canvas");
                        const leftCtx = leftCanvas.getContext("2d");
                        leftCanvas.width = splitX;
                        leftCanvas.height = origHeight;
                        leftCtx.drawImage(
                            img,
                            0,
                            0,
                            splitX,
                            origHeight,
                            0,
                            0,
                            splitX,
                            origHeight,
                        );
                        let leftResult = leftCanvas.toDataURL(
                            "image/jpeg",
                            0.85,
                        );

                        // Compress left if needed
                        let leftQuality = 0.85;
                        while (
                            leftResult.length > maxSizeKB * 1024 * 1.37 &&
                            leftQuality > 0.4
                        ) {
                            leftQuality -= 0.1;
                            leftResult = leftCanvas.toDataURL(
                                "image/jpeg",
                                leftQuality,
                            );
                        }

                        // === RIGHT HALF (for stats panel) ===
                        // Crop aggressively to stats table only (skip headers, footers, edges)
                        const rightCanvas = document.createElement("canvas");
                        const rightCtx = rightCanvas.getContext("2d");
                        const rightWidth = origWidth - splitX;

                        // Aggressive crop: keep only middle 80% vertically (skip headers/footers)
                        // and right 90% horizontally (skip left labels/edges)
                        const cropTopPercent = 0.1; // Skip top 10%
                        const cropBottomPercent = 0.15; // Skip bottom 15%
                        const cropLeftPercent = 0.05; // Skip left edge 5%
                        const cropRightPercent = 0.05; // Skip right edge 5%

                        const statsX = Math.round(rightWidth * cropLeftPercent);
                        const statsY = Math.round(origHeight * cropTopPercent);
                        const statsWidth = Math.round(
                            rightWidth *
                                (1 - cropLeftPercent - cropRightPercent),
                        );
                        const statsHeight = Math.round(
                            origHeight *
                                (1 - cropTopPercent - cropBottomPercent),
                        );

                        // Upscale cropped stats area to 1200px width for better OCR
                        const targetWidth = 1200;
                        const scale = targetWidth / statsWidth;
                        const targetHeight = Math.round(statsHeight * scale);

                        rightCanvas.width = targetWidth;
                        rightCanvas.height = targetHeight;
                        rightCtx.drawImage(
                            img,
                            splitX + statsX,
                            statsY,
                            statsWidth,
                            statsHeight,
                            0,
                            0,
                            targetWidth,
                            targetHeight,
                        );

                        // Compress right half
                        let rightQuality = 0.9;
                        let rightResult = rightCanvas.toDataURL(
                            "image/jpeg",
                            rightQuality,
                        );

                        while (
                            rightResult.length > maxSizeKB * 1024 * 1.37 &&
                            rightQuality > 0.4
                        ) {
                            rightQuality -= 0.1;
                            rightResult = rightCanvas.toDataURL(
                                "image/jpeg",
                                rightQuality,
                            );
                        }

                        // If right still too large, reduce dimensions
                        let currentWidth = targetWidth;
                        while (
                            rightResult.length > maxSizeKB * 1024 * 1.37 &&
                            currentWidth > 600
                        ) {
                            currentWidth = Math.round(currentWidth * 0.85);
                            const currentHeight = Math.round(
                                origHeight * (currentWidth / rightWidth),
                            );
                            rightCanvas.width = currentWidth;
                            rightCanvas.height = currentHeight;
                            rightCtx.drawImage(
                                img,
                                splitX,
                                0,
                                rightWidth,
                                origHeight,
                                0,
                                0,
                                currentWidth,
                                currentHeight,
                            );
                            rightResult = rightCanvas.toDataURL(
                                "image/jpeg",
                                0.85,
                            );
                        }

                        resolve({ left: leftResult, right: rightResult });
                    };
                    img.src = dataUrl;
                });
            }

            // Helper function to call OCR.space API
            async function callOCRAPI(base64Image, apiKey, useTable = false) {
                const formData = new FormData();
                formData.append("base64Image", base64Image);
                formData.append("language", "eng");
                formData.append("isOverlayRequired", "false");
                formData.append("OCREngine", "2");
                formData.append("scale", "true");
                if (useTable) {
                    formData.append("isTable", "true");
                }

                const response = await fetch(
                    "https://api.ocr.space/parse/image",
                    {
                        method: "POST",
                        headers: { apikey: apiKey },
                        body: formData,
                    },
                );

                const result = await response.json();

                if (result.IsErroredOnProcessing) {
                    throw new Error(
                        result.ErrorMessage || "OCR processing failed",
                    );
                }

                if (result.ParsedResults && result.ParsedResults.length > 0) {
                    return result.ParsedResults[0].ParsedText;
                }
                return "";
            }

            async function processScreenshot(file, statusDiv, progressDiv) {
                const apiKey = getOCRKey();

                return new Promise((resolve, reject) => {
                    const reader = new FileReader();

                    reader.onload = async function (e) {
                        try {
                            const base64Image = e.target.result;

                            if (apiKey) {
                                // DUAL-PASS OCR: Split image into left (header) and right (stats) halves
                                progressDiv.textContent = "Splitting image...";
                                const { left, right } =
                                    await splitImageForOCR(base64Image);

                                // Pass 1: OCR left half for mission header (no table mode)
                                progressDiv.textContent =
                                    "OCR: left half (headers)...";
                                const leftText = await callOCRAPI(
                                    left,
                                    apiKey,
                                    false,
                                );

                                // Pass 2: OCR right half for stats table (table mode + upscaled)
                                progressDiv.textContent =
                                    "OCR: right half (stats)...";
                                const rightText = await callOCRAPI(
                                    right,
                                    apiKey,
                                    true,
                                );

                                // Combine results: left half first (headers), then right half (stats)
                                const combinedText = `[LEFT]\n${leftText}\n[RIGHT]\n${rightText}`;
                                rawOCRText += combinedText + "\n\n---\n\n";

                                progressDiv.textContent = "OCR complete";
                            } else {
                                // Fallback to Tesseract.js (less accurate but works without key)
                                if (typeof Tesseract === "undefined") {
                                    throw new Error(
                                        "OCR library not loaded. Please refresh the page.",
                                    );
                                }

                                progressDiv.textContent =
                                    "Processing with basic OCR...";

                                try {
                                    const result = await Tesseract.recognize(
                                        base64Image,
                                        "eng",
                                        {
                                            logger: (m) => {
                                                if (
                                                    m.status ===
                                                    "recognizing text"
                                                ) {
                                                    progressDiv.textContent = `Basic OCR: ${Math.round(m.progress * 100)}%`;
                                                }
                                            },
                                        },
                                    );

                                    const text = result.data.text;
                                    rawOCRText += text + "\n\n---\n\n";
                                    progressDiv.textContent =
                                        "OCR complete (basic mode)";
                                } catch (tessError) {
                                    console.error(
                                        "Tesseract error:",
                                        tessError,
                                    );
                                    throw new Error(
                                        "Basic OCR failed. Try adding an API key for better results.",
                                    );
                                }
                            }

                            resolve();
                        } catch (error) {
                            reject(error);
                        }
                    };

                    reader.onerror = reject;
                    reader.readAsDataURL(file);
                });
            }

            function parseGameData(text) {
                // Heavy normalization for OCR text
                // Step 1: Remove symbols and normalize
                let normalized = text
                    .replace(/[\u2605\u2606]/g, "") // Remove star symbols
                    .replace(/[|]/g, " ") // Remove special chars
                    .replace(/xp\s*\d+/gi, " ") // Remove "XP 10" badges
                    .replace(/xb\s*\d+/gi, " ") // Remove "XB 10" (OCR misread)
                    .replace(/7k\b/gi, "") // Remove "7k" OCR artifact
                    .replace(/[''`]/g, "'") // Normalize quotes
                    .replace(/[""]/g, '"'); // Normalize double quotes

                // Step 2: Create uppercase version for matching
                let upperText = normalized.toUpperCase();

                // Step 3: Split into lines
                const lines = normalized
                    .split(/[\r\n]+/)
                    .map((l) => l.trim())
                    .filter((l) => l.length > 0);
                const upperSingleLine = upperText
                    .replace(/[\r\n]+/g, " ")
                    .replace(/\s+/g, " ");

                // === MISSION NAME ===
                // Known mission names in the game
                const knownMissions = [
                    "RECLAMATION",
                    "INFERNO",
                    "BALLISTIC",
                    "DECAPITATION",
                    "SERVO",
                    "SKULL",
                    "VANGUARD",
                    "VOIDSONG",
                    "RELIQUARY",
                    "TERMINATION",
                    "EXTRACTION",
                    "ATHENA",
                ];

                // Try full "MISSION: NAME" pattern first
                let missionMatch = upperSingleLine.match(
                    /MISSION\s*[:\-=]?\s*([A-Z][A-Z\s\-']{2,30})/,
                );
                if (missionMatch) {
                    let missionName = missionMatch[1].trim();
                    missionName = missionName
                        .replace(/\s*STATUS.*$/i, "")
                        .trim();
                    if (missionName.length > 2) {
                        pendingOCRResults["mission-name"] =
                            missionName.charAt(0) +
                            missionName.slice(1).toLowerCase();
                    }
                }

                // Fallback: Look for known mission names anywhere in text (handles split lines)
                if (!pendingOCRResults["mission-name"]) {
                    for (const mission of knownMissions) {
                        if (upperText.includes(mission)) {
                            pendingOCRResults["mission-name"] =
                                mission.charAt(0) +
                                mission.slice(1).toLowerCase();
                            break;
                        }
                    }
                }

                // === DIFFICULTY ===
                const difficulties = [
                    "MINIMAL",
                    "AVERAGE",
                    "SUBSTANTIAL",
                    "RUTHLESS",
                    "LETHAL",
                    "ABSOLUTE",
                ];
                for (const diff of difficulties) {
                    if (upperText.includes(diff)) {
                        pendingOCRResults["mission-difficulty"] =
                            diff.charAt(0) + diff.slice(1).toLowerCase();
                        break;
                    }
                }

                // === STATUS: SUCCESS ===
                if (
                    /STATUS\s*[:\-=]?\s*SUCCESS/i.test(upperText) ||
                    /\bVICTORY\b/i.test(upperText)
                ) {
                    pendingOCRResults["global-objective"] = "1";
                }

                // === GENE-SEED ===
                // Look for "Gene-Seed Found" or similar patterns
                // Can appear as "Gene-Seed Found", "GENESEED", or near SECONDARY OBJECTIVES
                const hasGeneseed = /GENE.?SEED/i.test(upperText);
                const hasFound = /FOUND|RETRIEVED/i.test(upperText);
                const hasSecondaryObj = /SECONDARY\s*OBJECTIVES/i.test(
                    upperText,
                );
                const geneseedWithXP = /GENE.?SEED.*?XP\s*\d+/i.test(
                    upperSingleLine,
                );

                if (
                    hasGeneseed &&
                    (hasFound || geneseedWithXP || hasSecondaryObj)
                ) {
                    pendingOCRResults["global-geneseed"] = "1";
                }

                // === PLAYER NAME AND CLASS ===
                // Levenshtein distance for fuzzy matching
                function levenshtein(a, b) {
                    if (a.length === 0) return b.length;
                    if (b.length === 0) return a.length;
                    const matrix = [];
                    for (let i = 0; i <= b.length; i++) matrix[i] = [i];
                    for (let j = 0; j <= a.length; j++) matrix[0][j] = j;
                    for (let i = 1; i <= b.length; i++) {
                        for (let j = 1; j <= a.length; j++) {
                            matrix[i][j] =
                                b[i - 1] === a[j - 1]
                                    ? matrix[i - 1][j - 1]
                                    : Math.min(
                                          matrix[i - 1][j - 1] + 1,
                                          matrix[i][j - 1] + 1,
                                          matrix[i - 1][j] + 1,
                                      );
                        }
                    }
                    return matrix[b.length][a.length];
                }

                // Canonical class names
                const canonicalClasses = [
                    "BULWARK",
                    "ASSAULT",
                    "VANGUARD",
                    "TACTICAL",
                    "SNIPER",
                    "HEAVY",
                    "TECHMARINE",
                ];

                // Known OCR misreads mapped to correct class
                const ocrClassFixes = {
                    ANGUNRO: "VANGUARD",
                    ANGUARD: "VANGUARD",
                    VANGUNRD: "VANGUARD",
                    VANGURD: "VANGUARD",
                    BULWAR: "BULWARK",
                    BLWARK: "BULWARK",
                    ASSAUL: "ASSAULT",
                    ASSAUT: "ASSAULT",
                    TACTIAL: "TACTICAL",
                    SNIPE: "SNIPER",
                    TECHMAR: "TECHMARINE",
                    ECHMAR: "TECHMARINE",
                };

                // Strict class matching - requires close match
                function matchClass(word) {
                    const upper = word.toUpperCase();
                    // Exact match
                    if (canonicalClasses.includes(upper)) return upper;
                    // Known OCR fix
                    if (ocrClassFixes[upper]) return ocrClassFixes[upper];
                    // Fuzzy match with strict distance <= 2
                    let bestMatch = null;
                    let bestDist = 3;
                    for (const cls of canonicalClasses) {
                        const dist = levenshtein(upper, cls);
                        if (dist < bestDist) {
                            bestDist = dist;
                            bestMatch = cls;
                        }
                    }
                    return bestDist <= 2 ? bestMatch : null;
                }

                // Format class name properly
                function formatClass(cls) {
                    return (
                        cls.charAt(0).toUpperCase() + cls.slice(1).toLowerCase()
                    );
                }

                // Collect all found players
                const foundPlayers = [];

                // Helper: Extract a valid player name from a line
                function extractPlayerName(line) {
                    // First try to extract names FROM brackets (OCR sometimes puts names inside)
                    // Pattern: [jr Name Lastname q] or similar
                    const bracketContent = line.match(
                        /\[(?:jr\s+)?([A-Z][a-z\u00E0-\u00FF]+(?:\s+[A-Za-z\u00E0-\u00FF]+)*)\s*[qQ\]]/i,
                    );
                    if (bracketContent && bracketContent[1].length >= 3) {
                        // Clean the extracted name - remove trailing single chars
                        let extracted = bracketContent[1]
                            .trim()
                            .replace(/\s+[a-zA-Z]$/g, "")
                            .trim();
                        if (
                            !/^(Kills|Special|Heavy|Assault|Bulwark|Vanguard|Tactical|Sniper)/i.test(
                                extracted,
                            )
                        ) {
                            return extracted;
                        }
                    }

                    // Remove brackets and clean the line
                    const cleanLine = line.replace(/\[.*?\]/g, "").trim();
                    
                    // Filter out OCR preprocessing markers
                    if (/^\[?(LEFT|RIGHT)\]?$/i.test(cleanLine)) {
                        return null;
                    }

                    // Game terms and garbage patterns to filter out
                    const gameTerms =
                        /^(Kills|Special|Melee|Ranged|Damage|Items|Total|Score|Next|Status|Mission|Rewards|Character|Progress|Primary|Secondary|Objectives|Found|Taken|Revived|Incap|Success|Assault|Vanguard|Bulwark|Tactical|Sniper|Heavy|TRUER|SYREN)$/i;

                    // Filter out garbage: all same letter, too short, suspicious patterns
                    function isValidName(name) {
                        if (!name || name.length < 3) return false;
                        if (gameTerms.test(name)) return false;
                        // Reject if all same letter (EEE, RRR, etc)
                        if (/^(.)\1+$/i.test(name)) return false;
                        // Reject all-caps short strings (likely OCR noise)
                        if (name === name.toUpperCase() && name.length < 5)
                            return false;
                        // Reject if mostly non-letters
                        const letterCount = (
                            name.match(/[a-zA-Z\u00C0-\u00FF]/g) || []
                        ).length;
                        if (letterCount < name.length * 0.7) return false;
                        // Reject weird case patterns like "AajE" (uppercase at end of short word)
                        if (name.length <= 5 && /[a-z][A-Z]$/.test(name))
                            return false;
                        // Reject if contains multiple random uppercase in the middle
                        const midUppers = (
                            name.slice(1, -1).match(/[A-Z]/g) || []
                        ).length;
                        if (name.length <= 5 && midUppers > 1) return false;
                        // Reject very short names that look like OCR artifacts
                        if (name.length <= 4 && !/^[A-Z][a-z]{2,3}$/.test(name))
                            return false;
                        return true;
                    }

                    // Strategy A: Look for proper case names (Uppercase + lowercase)
                    const properMatch = cleanLine.match(
                        /\b([A-Z][a-z\u00E0-\u00FF]{2,}(?:\s+[A-Z]?[a-z\u00E0-\u00FF]{2,})*)\b/,
                    );
                    if (properMatch && isValidName(properMatch[1])) {
                        // Clean trailing garbage like "i", "py", "q" from "Zephon py"
                        let cleaned = properMatch[1]
                            .replace(/\s+[a-z]{1,2}$/i, "")
                            .trim();
                        // Also remove trailing single lowercase words under 3 chars
                        cleaned = cleaned.replace(/\s+\S{1,2}$/g, "").trim();
                        return cleaned;
                    }

                    // Strategy B: Mixed case names
                    const mixedMatch = cleanLine.match(
                        /\b([A-Z][A-Za-z\u00C0-\u00FF]{3,})\b/,
                    );
                    if (mixedMatch && isValidName(mixedMatch[1])) {
                        return mixedMatch[1];
                    }

                    return null;
                }

                // STRATEGY 1: Look for class names with [a] or [i] markers (game UI pattern)
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];

                    // Look for pattern: word followed by [a], [i], [E], [of], [a], etc. (OCR variations)
                    const markerMatch = line.match(
                        /([A-Za-z]{4,})\s*\[([aieAIEof0-9]{1,2})\]/i,
                    );
                    if (markerMatch) {
                        const potentialClass = markerMatch[1];
                        const matchedClass = matchClass(potentialClass);

                        if (matchedClass && foundPlayers.length < 3) {
                            // Skip level indicators like "Bulwark MAX"
                            const beforeMatch = line.substring(
                                0,
                                line.indexOf(markerMatch[0]),
                            );
                            if (/MAX\b/i.test(beforeMatch)) continue;

                            let foundName = null;

                            // First check the SAME LINE before the class marker for a name
                            if (beforeMatch.trim()) {
                                const sameLine = beforeMatch
                                    .replace(/[|:$#\[\]0-9]/g, " ")
                                    .trim();
                                const sameLineName =
                                    extractPlayerName(sameLine);
                                if (sameLineName) {
                                    const isDuplicate = foundPlayers.some(
                                        (p) => p.name === sameLineName,
                                    );
                                    if (!isDuplicate) {
                                        foundName = sameLineName;
                                    }
                                }
                            }

                            // If not found on same line, look backwards up to 6 lines
                            if (!foundName) {
                                for (
                                    let j = i - 1;
                                    j >= Math.max(0, i - 6);
                                    j--
                                ) {
                                    const name = extractPlayerName(lines[j]);
                                    if (name) {
                                        const isDuplicate = foundPlayers.some(
                                            (p) => p.name === name,
                                        );
                                        if (!isDuplicate) {
                                            foundName = name;
                                            break;
                                        }
                                    }
                                }
                            }

                            if (foundName) {
                                foundPlayers.push({
                                    name: foundName,
                                    class: formatClass(matchedClass),
                                });
                            }
                        }
                    }
                }

                // STRATEGY 2: Look for name [i] pattern (player name marker)
                if (foundPlayers.length < 3) {
                    for (let i = 0; i < lines.length; i++) {
                        if (foundPlayers.length >= 3) break;

                        const line = lines[i];
                        // Look for "Name [i]" pattern - player names often have [i] after them
                        const nameMarkerMatch = line.match(
                            /([A-Z][a-z\u00E0-\u00FF]+(?:\s+[A-Za-z\u00E0-\u00FF]+)*)\s*\[i\]/i,
                        );
                        if (nameMarkerMatch) {
                            const candidateName = nameMarkerMatch[1].trim();
                            if (candidateName.length >= 3) {
                                // Look forward for class
                                for (
                                    let j = i + 1;
                                    j <= Math.min(lines.length - 1, i + 3);
                                    j++
                                ) {
                                    const classLine = lines[j];
                                    const classMatch = classLine.match(
                                        /([A-Za-z]{4,})\s*\[a\]/i,
                                    );
                                    if (classMatch) {
                                        const matchedClass = matchClass(
                                            classMatch[1],
                                        );
                                        if (matchedClass) {
                                            const isDuplicate =
                                                foundPlayers.some(
                                                    (p) =>
                                                        p.name ===
                                                        candidateName,
                                                );
                                            if (!isDuplicate) {
                                                foundPlayers.push({
                                                    name: candidateName,
                                                    class: formatClass(
                                                        matchedClass,
                                                    ),
                                                });
                                            }
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                // STRATEGY 2.5: Look for class names followed by ANY bracket (more flexible)
                if (foundPlayers.length < 3) {
                    for (let i = 0; i < lines.length; i++) {
                        if (foundPlayers.length >= 3) break;

                        const line = lines[i];
                        if (/\bMAX\b/i.test(line)) continue;

                        // More flexible pattern: class name followed by bracket with anything
                        const flexMatch = line.match(
                            /\b([A-Za-z]{5,})\s*\[[^\]]{0,3}\]/i,
                        );
                        if (flexMatch) {
                            const potentialClass = flexMatch[1];
                            const matchedClass = matchClass(potentialClass);

                            if (matchedClass) {
                                // Check if this class already detected
                                const classAlreadyFound = foundPlayers.some(
                                    (p) =>
                                        p.class.toLowerCase() ===
                                        matchedClass.toLowerCase(),
                                );
                                if (classAlreadyFound) continue;

                                let foundName = null;
                                const beforeMatch = line.substring(
                                    0,
                                    line.indexOf(flexMatch[0]),
                                );

                                // Check same line first
                                if (beforeMatch.trim()) {
                                    const sameLine = beforeMatch
                                        .replace(/[|:$#\[\]0-9]/g, " ")
                                        .trim();
                                    foundName = extractPlayerName(sameLine);
                                    if (
                                        foundName &&
                                        foundPlayers.some(
                                            (p) => p.name === foundName,
                                        )
                                    ) {
                                        foundName = null;
                                    }
                                }

                                // Look backwards
                                if (!foundName) {
                                    for (
                                        let j = i - 1;
                                        j >= Math.max(0, i - 6);
                                        j--
                                    ) {
                                        const name = extractPlayerName(
                                            lines[j],
                                        );
                                        if (
                                            name &&
                                            !foundPlayers.some(
                                                (p) => p.name === name,
                                            )
                                        ) {
                                            foundName = name;
                                            break;
                                        }
                                    }
                                }

                                if (foundName) {
                                    foundPlayers.push({
                                        name: foundName,
                                        class: formatClass(matchedClass),
                                    });
                                }
                            }
                        }
                    }
                }

                // STRATEGY 3: Fallback - look for standalone class names (skip MAX lines)
                if (foundPlayers.length < 3) {
                    for (let i = 0; i < lines.length; i++) {
                        if (foundPlayers.length >= 3) break;

                        const line = lines[i].trim();
                        if (/\bMAX\b/i.test(line)) continue;

                        // Extract words and try matching
                        const words = line.match(/[A-Za-z]{5,}/g) || [];
                        for (const word of words) {
                            const matchedClass = matchClass(word);
                            if (matchedClass) {
                                // Check if this class already detected
                                const classAlreadyFound = foundPlayers.some(
                                    (p) =>
                                        p.class.toLowerCase() ===
                                        matchedClass.toLowerCase(),
                                );
                                if (classAlreadyFound) continue;

                                // Look backwards for name
                                for (
                                    let j = i - 1;
                                    j >= Math.max(0, i - 6);
                                    j--
                                ) {
                                    const name = extractPlayerName(lines[j]);
                                    if (name) {
                                        const isDuplicate = foundPlayers.some(
                                            (p) => p.name === name,
                                        );
                                        if (!isDuplicate) {
                                            foundPlayers.push({
                                                name: name,
                                                class: formatClass(
                                                    matchedClass,
                                                ),
                                            });
                                            break;
                                        }
                                    }
                                }
                                break;
                            }
                        }
                    }
                }

                // STRATEGY 4: Handle "CLASS MAX" patterns (Character Progress section)
                // This catches cases where the viewing player's class appears as "Heavy MAX" etc.
                if (foundPlayers.length < 3) {
                    for (let i = 0; i < lines.length; i++) {
                        if (foundPlayers.length >= 3) break;

                        const line = lines[i].trim();
                        // Match pattern like "Heavy MAX" or "25 Heavy MAX"
                        const maxMatch = line.match(
                            /\b([A-Za-z]{5,})\s+MAX\b/i,
                        );
                        if (maxMatch) {
                            const potentialClass = maxMatch[1];
                            const matchedClass = matchClass(potentialClass);
                            if (matchedClass) {
                                const classAlreadyFound = foundPlayers.some(
                                    (p) =>
                                        p.class.toLowerCase() ===
                                        matchedClass.toLowerCase(),
                                );
                                if (classAlreadyFound) continue;

                                // Look backwards and forwards for name - require higher confidence
                                // Since CLASS MAX context often has garbled OCR, require longer names (5+ chars)
                                // or names that look very name-like
                                let foundName = null;

                                function isHighConfidenceName(name) {
                                    if (!name) return false;
                                    // Require at least 5 chars, OR known OCR pattern for Brni
                                    if (name.length >= 5) return true;
                                    if (/^B[o]rni$/i.test(name)) return true;
                                    // Reject very short names from garbage lines
                                    return false;
                                }

                                for (
                                    let j = i - 1;
                                    j >= Math.max(0, i - 8);
                                    j--
                                ) {
                                    const candidateLine = lines[j];
                                    // Skip lines that look like garbage (lots of symbols, very short words)
                                    if (
                                        /^[\s\[\]\(\)\{\}|\\\/\-\.\,\;\:\#\@\!\?\*\&\%\$\=\+\<\>\~\`\'\"0-9]+$/.test(
                                            candidateLine,
                                        )
                                    )
                                        continue;

                                    const name =
                                        extractPlayerName(candidateLine);
                                    if (
                                        isHighConfidenceName(name) &&
                                        !foundPlayers.some(
                                            (p) => p.name === name,
                                        )
                                    ) {
                                        foundName = name;
                                        break;
                                    }
                                }

                                // Also look forward if not found
                                if (!foundName) {
                                    for (
                                        let j = i + 1;
                                        j <= Math.min(lines.length - 1, i + 4);
                                        j++
                                    ) {
                                        const candidateLine = lines[j];
                                        if (
                                            /^[\s\[\]\(\)\{\}|\\\/\-\.\,\;\:\#\@\!\?\*\&\%\$\=\+\<\>\~\`\'\"0-9]+$/.test(
                                                candidateLine,
                                            )
                                        )
                                            continue;

                                        const name =
                                            extractPlayerName(candidateLine);
                                        if (
                                            isHighConfidenceName(name) &&
                                            !foundPlayers.some(
                                                (p) => p.name === name,
                                            )
                                        ) {
                                            foundName = name;
                                            break;
                                        }
                                    }
                                }

                                // If we have a class but no confident name, add with empty name
                                // (user can fill name in review modal)
                                foundPlayers.push({
                                    name: foundName || "",
                                    class: formatClass(matchedClass),
                                });
                            }
                        }
                    }
                }

                // STRATEGY 5: Look for "Name\nCLASS" pattern in stats panel header
                // The stats panel shows "ShovelKnight\nTACTICAL" at the top
                if (foundPlayers.length < 3) {
                    for (let i = 0; i < lines.length - 1; i++) {
                        if (foundPlayers.length >= 3) break;

                        const line = lines[i].trim();
                        const nextLine = lines[i + 1].trim().toUpperCase();

                        // Check if next line is a class name
                        const matchedClass = matchClass(nextLine);
                        if (matchedClass) {
                            const classAlreadyFound = foundPlayers.some(
                                (p) =>
                                    p.class.toLowerCase() ===
                                    matchedClass.toLowerCase(),
                            );
                            if (classAlreadyFound) continue;

                            // Current line might be the player name
                            const name = extractPlayerName(line);
                            if (
                                name &&
                                name.length >= 3 &&
                                !foundPlayers.some((p) => p.name === name)
                            ) {
                                foundPlayers.push({
                                    name: name,
                                    class: formatClass(matchedClass),
                                });
                            }
                        }
                    }
                }

                // Assign players in REVERSE order (OCR sections appear in reverse screenshot order)
                // Column 1 stats = last found player, Column 3 stats = first found player
                const reversedPlayers = [...foundPlayers].reverse();
                for (let p = 0; p < reversedPlayers.length && p < 3; p++) {
                    const slot = p + 1;
                    if (!pendingOCRResults[`p${slot}-name`]) {
                        pendingOCRResults[`p${slot}-name`] =
                            reversedPlayers[p].name;
                        pendingOCRResults[`p${slot}-class`] =
                            reversedPlayers[p].class;
                    }
                }

                // === EXTRACT STATS ===
                // For stats, look for the last 3 numbers on a line containing the label
                // This handles cases like "Kills XB 10 460 453 425" where we want the last 3

                function extractLastThreeNumbers(
                    labelPatterns,
                    excludeRegex = null,
                    defaultToZero = false,
                ) {
                    // Accept array of patterns to try (more lenient options)
                    const patterns = Array.isArray(labelPatterns)
                        ? labelPatterns
                        : [labelPatterns];
                    let labelFound = false;

                    for (const labelRegex of patterns) {
                        for (const line of lines) {
                            const upperLine = line.toUpperCase();
                            if (labelRegex.test(upperLine)) {
                                // Skip if exclude pattern matches (e.g., skip "SPECIAL KILLS" for "KILLS")
                                if (
                                    excludeRegex &&
                                    excludeRegex.test(upperLine)
                                )
                                    continue;
                                labelFound = true;
                                // Find all numbers in this line
                                const nums = line.match(/\d+/g);
                                if (nums && nums.length >= 1) {
                                    // Take up to the last 3 numbers (skip XP badge numbers)
                                    const lastNums = nums
                                        .slice(-Math.min(3, nums.length))
                                        .map((n) => parseInt(n));
                                    if (
                                        lastNums.every(
                                            (n) =>
                                                !isNaN(n) &&
                                                n >= 0 &&
                                                n < 1000000,
                                        )
                                    ) {
                                        // Pad with nulls if fewer than 3 numbers found
                                        while (lastNums.length < 3) {
                                            lastNums.push(null);
                                        }
                                        return lastNums;
                                    }
                                }
                            }
                        }
                    }
                    // If label was found but no numbers, and defaultToZero is true, return zeros
                    // This handles OCR missing small "0" characters for counter fields
                    if (labelFound && defaultToZero) {
                        return [0, 0, 0];
                    }
                    return null;
                }

                // Helper to assign stats - only sets non-null values
                function assignStats(nums, statName) {
                    if (!nums) return;
                    if (nums[0] !== null)
                        pendingOCRResults[`p1-${statName}`] = nums[0];
                    if (nums[1] !== null)
                        pendingOCRResults[`p2-${statName}`] = nums[1];
                    if (nums[2] !== null)
                        pendingOCRResults[`p3-${statName}`] = nums[2];
                }

                // Kills - try multiple patterns (OCR can mangle text)
                const killsNums = extractLastThreeNumbers(
                    [
                        /\bKILLS\b/, // Standard: "Kills"
                        /K[I1l]{1,2}[L1]{1,2}S/i, // OCR variants: "Ki11s", "Kllls"
                        /KILLS/, // No word boundary (catches "4Kills" etc.)
                    ],
                    /SPECIAL|SPECIA/i,
                );
                assignStats(killsNums, "kills");

                // Special Kills -> Elite Kills
                const specialNums = extractLastThreeNumbers([
                    /SPECIAL\s*KILLS/,
                    /SPEC[I1]AL\s*K[I1]LLS/i, // OCR variants
                    /SPECIA.*KILLS/i, // Partial match
                ]);
                assignStats(specialNums, "elite");

                // Incapacitations -> Death
                // Special handling: OCR sometimes reads "0" as "U" or "O" on this line
                let incapNums = null;
                const incapPatterns = [/INCAPACITATION/i, /INCAP/i];
                for (const pattern of incapPatterns) {
                    for (const line of lines) {
                        if (pattern.test(line.toUpperCase())) {
                            // Replace U and O with 0 for this specific line (OCR misreads)
                            const fixedLine = line.replace(/\b[UO]\b/g, "0");
                            const nums = fixedLine.match(/\d+/g);
                            if (nums && nums.length >= 1) {
                                const lastNums = nums
                                    .slice(-Math.min(3, nums.length))
                                    .map((n) => parseInt(n));
                                if (
                                    lastNums.every(
                                        (n) => !isNaN(n) && n >= 0 && n < 100,
                                    )
                                ) {
                                    while (lastNums.length < 3)
                                        lastNums.push(null);
                                    incapNums = lastNums;
                                    break;
                                }
                            }
                        }
                    }
                    if (incapNums) break;
                }
                assignStats(incapNums, "death");

                // Damage Taken -> Damage
                const damageNums = extractLastThreeNumbers([
                    /DAMAGE\s*TAKEN/,
                    /DAMAGE.*TAKEN/i, // More flexible spacing
                    /DAM.*TAK/i, // Very short match
                ]);
                assignStats(damageNums, "damage");

                // === WAVES (Siege Mode) ===
                // Extract wave number from "STATUS: WAVE 15" or similar
                const waveMatch = upperText.match(/STATUS\s*[:\-=]?\s*WAVE\s+(\d+)/i);
                if (waveMatch) {
                    pendingOCRResults["global-waves"] = waveMatch[1];
                }

                // === ARMOURY DATA ===
                // Look for patterns near "REWARDS" section (Operations mode)
                // Also check for armoury in Battle Honours area (Siege mode) or other areas
                let armouryFound = false;

                // First try REWARDS section
                const rewardsIdx = upperText.indexOf("REWARDS");
                if (rewardsIdx !== -1) {
                    // Get text after REWARDS (next 150 chars)
                    const afterRewards = text.substring(
                        rewardsIdx,
                        rewardsIdx + 150,
                    );
                    const afterRewardsUpper = afterRewards.toUpperCase();

                    // Skip if we've hit CHARACTER PROGRESS (means we went too far)
                    const progressIdx = afterRewardsUpper.indexOf("CHARACTER");
                    const cleanText =
                        progressIdx > 0
                            ? afterRewards.substring(0, progressIdx)
                            : afterRewards;

                    // Split by lines AND tabs to find individual numbers
                    const tokens = cleanText
                        .split(/[\r\n\t]+/)
                        .map((t) => t.trim())
                        .filter((t) => t);

                    // Find all numbers in the REWARDS area
                    const numbersFound = [];
                    for (const token of tokens) {
                        const nums = token.match(/\d+/g);
                        if (nums) {
                            nums.forEach((n) => numbersFound.push(parseInt(n)));
                        }
                    }

                    // Armoury is 0-3, requisition is typically 260
                    // Find the small number (0-3) that's NOT the requisition value
                    for (const num of numbersFound) {
                        if (num >= 0 && num <= 3) {
                            // Make sure there's also a larger number (requisition) present
                            const hasRequisition = numbersFound.some(
                                (n) => n >= 100 && n <= 500,
                            );
                            if (hasRequisition || numbersFound.length >= 1) {
                                pendingOCRResults["global-armoury"] =
                                    num.toString();
                                armouryFound = true;
                                break;
                            }
                        }
                    }

                    // Fallback: Look for tab-separated pattern "2\t260" or "2 260"
                    if (!armouryFound) {
                        const tabMatch = cleanText.match(
                            /([0-3])[\t\s]+(\d{2,3})/,
                        );
                        if (tabMatch && parseInt(tabMatch[2]) >= 100) {
                            pendingOCRResults["global-armoury"] = tabMatch[1];
                            armouryFound = true;
                        }
                    }
                }

                // Fallback for Siege Mode: Look for armoury data anywhere in the text (not just REWARDS)
                if (!armouryFound) {
                    // Look for icon patterns or numbers near "ARMOURY" text
                    const armouryIdx = upperText.indexOf("ARMOURY");
                    if (armouryIdx !== -1) {
                        const nearArmoury = text.substring(
                            Math.max(0, armouryIdx - 50),
                            armouryIdx + 100,
                        );
                        const armouryMatch = nearArmoury.match(
                            /([0-3])[\s\t]+(?:XP|\d{2,}|.*)/i,
                        );
                        if (armouryMatch) {
                            pendingOCRResults["global-armoury"] =
                                armouryMatch[1];
                            armouryFound = true;
                        }
                    }
                }

                // Don't default - let user select from dropdown if not found

                // === GENE-SEED DEFAULT ===
                // If gene-seed was not detected anywhere in the text, default to "No"
                // Gene-seed is only mentioned when it IS retrieved
                if (!pendingOCRResults["global-geneseed"]) {
                    const hasGeneseedMention = /GENE.?SEED|GENESEED/i.test(
                        upperText,
                    );
                    if (!hasGeneseedMention) {
                        pendingOCRResults["global-geneseed"] = "0"; // No
                    }
                }
            }

            // Show OCR review modal
            function showOCRModal() {
                const modal = document.getElementById("ocr-modal-overlay");
                const grid = document.getElementById("ocr-detected-grid");
                const rawTextDiv = document.getElementById("ocr-raw-text");

                // Display raw text
                rawTextDiv.textContent = rawOCRText || "No text detected";

                // Helper to create input HTML
                function createInput(key, type, label) {
                    const value = pendingOCRResults[key];
                    // Explicitly handle 0 as a valid detected value (not missing)
                    const hasValue =
                        value !== undefined &&
                        value !== null &&
                        String(value) !== "";
                    let displayValue = hasValue ? value : "";

                    // Format special values
                    if (key === "global-objective" && value === "1")
                        displayValue = "Yes";
                    if (key === "global-geneseed" && value === "1")
                        displayValue = "Yes";
                    if (key === "global-geneseed" && value === "0")
                        displayValue = "No";

                    let inputHTML = "";
                    if (type === "difficulty") {
                        inputHTML = `
                            <select class="ocr-input ocr-select" data-key="${key}">
                                <option value="">- Select -</option>
                                <option value="Minimal" ${displayValue === "Minimal" ? "selected" : ""}>Minimal</option>
                                <option value="Average" ${displayValue === "Average" ? "selected" : ""}>Average</option>
                                <option value="Substantial" ${displayValue === "Substantial" ? "selected" : ""}>Substantial</option>
                                <option value="Ruthless" ${displayValue === "Ruthless" ? "selected" : ""}>Ruthless</option>
                                <option value="Lethal" ${displayValue === "Lethal" ? "selected" : ""}>Lethal</option>
                                <option value="Absolute" ${displayValue === "Absolute" ? "selected" : ""}>Absolute</option>
                                <option value="Normal" ${displayValue === "Normal" ? "selected" : ""}>Normal</option>
                                <option value="Hard" ${displayValue === "Hard" ? "selected" : ""}>Hard</option>
                            </select>`;
                    } else if (type === "class") {
                        inputHTML = `
                            <select class="ocr-input ocr-select" data-key="${key}">
                                <option value="">- Select -</option>
                                <option value="Tactical" ${displayValue === "Tactical" ? "selected" : ""}>Tactical</option>
                                <option value="Assault" ${displayValue === "Assault" ? "selected" : ""}>Assault</option>
                                <option value="Vanguard" ${displayValue === "Vanguard" ? "selected" : ""}>Vanguard</option>
                                <option value="Bulwark" ${displayValue === "Bulwark" ? "selected" : ""}>Bulwark</option>
                                <option value="Sniper" ${displayValue === "Sniper" ? "selected" : ""}>Sniper</option>
                                <option value="Heavy" ${displayValue === "Heavy" ? "selected" : ""}>Heavy</option>
                                <option value="Techmarine" ${displayValue === "Techmarine" ? "selected" : ""}>Techmarine</option>
                            </select>`;
                    } else if (type === "yesno") {
                        const yesSelected =
                            displayValue === "Yes" ? "selected" : "";
                        const noSelected =
                            displayValue === "No" || !hasValue
                                ? "selected"
                                : "";
                        inputHTML = `
                            <select class="ocr-input ocr-select" data-key="${key}">
                                <option value="0" ${noSelected}>No</option>
                                <option value="1" ${yesSelected}>Yes</option>
                            </select>`;
                    } else if (type === "armoury") {
                        inputHTML = `
                            <select class="ocr-input ocr-select" data-key="${key}">
                                <option value="0" ${displayValue === "0" ? "selected" : ""}>0</option>
                                <option value="1" ${displayValue === "1" ? "selected" : ""}>1</option>
                                <option value="2" ${displayValue === "2" ? "selected" : ""}>2</option>
                                <option value="3" ${displayValue === "3" ? "selected" : ""}>3</option>
                            </select>`;
                    } else if (type === "number") {
                        inputHTML = `<input type="number" class="ocr-input" data-key="${key}" value="${displayValue}" min="0" placeholder="0">`;
                    } else {
                        inputHTML = `<input type="text" class="ocr-input" data-key="${key}" value="${displayValue}" placeholder="Not detected">`;
                    }

                    return `
                        <div class="ocr-detected-item ${hasValue ? "" : "not-found"}">
                            <span class="ocr-detected-label">${label}:</span>
                            ${inputHTML}
                        </div>
                    `;
                }

                // Build grouped layout
                let gridHTML = "";

                // Mission Info Section
                gridHTML += `<div class="ocr-section"><div class="ocr-section-title">Mission Info</div>`;
                gridHTML += createInput("mission-name", "text", "Mission");
                gridHTML += createInput(
                    "mission-difficulty",
                    "difficulty",
                    "Difficulty",
                );
                gridHTML += createInput(
                    "global-objective",
                    "yesno",
                    "Objective Complete",
                );
                gridHTML += createInput(
                    "global-geneseed",
                    "yesno",
                    "Geneseed Retrieved",
                );
                gridHTML += createInput(
                    "global-armoury",
                    "armoury",
                    "Armoury Data",
                );
                gridHTML += createInput(
                    "global-waves",
                    "number",
                    "Waves Reached",
                );
                gridHTML += `</div>`;

                // Space Marine sections
                for (let p = 1; p <= 3; p++) {
                    gridHTML += `<div class="ocr-section ocr-player-section"><div class="ocr-section-title">Space Marine ${p}</div>`;
                    gridHTML += createInput(`p${p}-name`, "text", "Name");
                    gridHTML += createInput(`p${p}-class`, "class", "Class");
                    gridHTML += `<div class="ocr-stats-row">`;
                    gridHTML += createInput(`p${p}-kills`, "number", "Kills");
                    gridHTML += createInput(`p${p}-elite`, "number", "Special Kills");
                    gridHTML += createInput(`p${p}-death`, "number", "Incapacitations");
                    gridHTML += createInput(`p${p}-damage`, "number", "Damage Taken");
                    gridHTML += `</div></div>`;
                }

                grid.innerHTML = gridHTML;

                // Show modal
                modal.classList.add("active");
            }

            // Apply OCR results to form
            function applyOCRResults() {
                // Read values from the editable input fields in the modal
                const inputs = document.querySelectorAll(".ocr-input");
                inputs.forEach((input) => {
                    const key = input.dataset.key;
                    const value = input.value;
                    const el = document.getElementById(key);
                    if (el && value !== undefined && value !== "") {
                        el.value = value;
                    }
                });

                // Recalculate and save
                calculate();
                saveData();

                // Close modal
                closeOCRModal();

                // Update status
                const statusDiv = document.getElementById("upload-status");
                statusDiv.textContent = "Values applied successfully!";
                statusDiv.style.color = "#afffa6";
            }

            // Close OCR modal
            function closeOCRModal() {
                const modal = document.getElementById("ocr-modal-overlay");
                modal.classList.remove("active");
            }

            // Export OCR debug data for troubleshooting
            function exportOCRDebug() {
                // Get current version from header
                const headerDecor = document.querySelector(".header-decor");
                const versionText = headerDecor?.textContent || "";
                const versionMatch = versionText.match(/V\s*(\d+\.\d+\.\d+)/i);
                const currentVersion = versionMatch
                    ? versionMatch[1]
                    : "unknown";

                const debugData = {
                    version: currentVersion,
                    timestamp: new Date().toISOString(),
                    detectedValues: pendingOCRResults,
                    rawOCRText: rawOCRText,
                };

                // Create formatted debug output
                let output = "=== OCR DEBUG EXPORT ===\n";
                output += `Version: ${debugData.version}\n`;
                output += `Timestamp: ${debugData.timestamp}\n\n`;

                output += "=== DETECTED VALUES ===\n";
                for (const [key, value] of Object.entries(pendingOCRResults)) {
                    output += `${key}: ${value}\n`;
                }

                output += "\n=== RAW OCR TEXT ===\n";
                output += rawOCRText;

                output += "\n\n=== ANALYSIS ===\n";
                // Check what lines contain stats keywords
                const lines = rawOCRText.split(/[\r\n]+/);
                output += "Lines containing 'KILL' (case-insensitive):\n";
                lines.forEach((line, i) => {
                    if (/kill/i.test(line)) {
                        output += `  Line ${i}: ${line}\n`;
                        // Show what numbers were found
                        const nums = line.match(/\d+/g);
                        output += `    Numbers found: ${nums ? nums.join(", ") : "NONE"}\n`;
                    }
                });

                output += "\nLines containing 'INCAP' (case-insensitive):\n";
                lines.forEach((line, i) => {
                    if (/incap/i.test(line)) {
                        output += `  Line ${i}: ${line}\n`;
                        const nums = line.match(/\d+/g);
                        output += `    Numbers found: ${nums ? nums.join(", ") : "NONE"}\n`;
                    }
                });

                output += "\nLines containing 'DAMAGE' (case-insensitive):\n";
                lines.forEach((line, i) => {
                    if (/damage/i.test(line)) {
                        output += `  Line ${i}: ${line}\n`;
                        const nums = line.match(/\d+/g);
                        output += `    Numbers found: ${nums ? nums.join(", ") : "NONE"}\n`;
                    }
                });

                // Download the file
                const blob = new Blob([output], { type: "text/plain" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = `ocr_debug_${Date.now()}.txt`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            // Clear all data except modifiers
            function clearData() {
                if (
                    !confirm("Clear all mission data? (Modifiers will be kept)")
                ) {
                    return;
                }

                // List of fields to clear (everything except modifiers)
                const fieldsToClear = [
                    "mission-name",
                    "mission-difficulty",
                    "global-objective",
                    "global-geneseed",
                    "global-armoury",
                    "p1-name",
                    "p2-name",
                    "p3-name",
                    "p1-class",
                    "p2-class",
                    "p3-class",
                    "p1-kills",
                    "p2-kills",
                    "p3-kills",
                    "p1-elite",
                    "p2-elite",
                    "p3-elite",
                    "p1-death",
                    "p2-death",
                    "p3-death",
                    "p1-damage",
                    "p2-damage",
                    "p3-damage",
                ];

                fieldsToClear.forEach((id) => {
                    const el = document.getElementById(id);
                    if (el) {
                        if (el.tagName === "SELECT") {
                            el.selectedIndex = 0; // Reset to placeholder
                        } else {
                            el.value = el.type === "number" ? "0" : "";
                        }
                    }
                });

                // Recalculate and save
                calculate();
                saveData();
            }
        </script>
        <script>
            const STORAGE_KEY = "missionDebriefData";

            // List of all input/select IDs to save
            const inputIds = [
                "mod-kills",
                "mod-elite",
                "mod-death",
                "mod-damage",
                "mod-gene",
                "mod-armoury",
                "mod-obj",
                "mission-name",
                "mission-difficulty",
                "global-objective",
                "global-geneseed",
                "global-armoury",
                "p1-name",
                "p2-name",
                "p3-name",
                "p1-class",
                "p2-class",
                "p3-class",
                "p1-kills",
                "p2-kills",
                "p3-kills",
                "p1-elite",
                "p2-elite",
                "p3-elite",
                "p1-death",
                "p2-death",
                "p3-death",
                "p1-damage",
                "p2-damage",
                "p3-damage",
            ];

            // Save all form data to localStorage
            function saveData() {
                const data = {};
                inputIds.forEach((id) => {
                    const el = document.getElementById(id);
                    if (el) {
                        data[id] = el.value;
                    }
                });
                try {
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
                } catch (e) {
                    console.warn("Could not save to localStorage:", e);
                }
            }

            // Load all form data from localStorage
            function loadData() {
                try {
                    const saved = localStorage.getItem(STORAGE_KEY);
                    if (saved) {
                        const data = JSON.parse(saved);
                        inputIds.forEach((id) => {
                            const el = document.getElementById(id);
                            if (
                                el &&
                                data[id] !== undefined &&
                                data[id] !== ""
                            ) {
                                el.value = data[id];
                            }
                        });
                    }
                } catch (e) {
                    console.warn("Could not load from localStorage:", e);
                }
            }

            // Helper to get float value from input ID, defaults to 0
            function getVal(id) {
                const el = document.getElementById(id);
                if (!el) return 0;
                const val = parseFloat(el.value);
                return isNaN(val) ? 0 : val;
            }
            // Helper to get string value from input ID, defaults to empty
            function getStr(id) {
                const el = document.getElementById(id);
                return el ? el.value.trim() : "";
            }

            // Helper to set text content of element
            function setTxt(id, txt) {
                const el = document.getElementById(id);
                if (el) el.textContent = txt;
            }

            function calculate() {
                // 1. Get Modifiers
                const modKills = getVal("mod-kills");
                const modElite = getVal("mod-elite");
                const modDeath = getVal("mod-death");
                const modDamage = getVal("mod-damage");
                const modGene = getVal("mod-gene");
                const modArmoury = getVal("mod-armoury");
                const modObj = getVal("mod-obj");

                // 2. Get Global statuses (handling empty string from placeholder)
                const globalObj =
                    document.getElementById("global-objective").value === ""
                        ? 0
                        : getVal("global-objective");
                const globalGene =
                    document.getElementById("global-geneseed").value === ""
                        ? 0
                        : getVal("global-geneseed");
                const globalArmoury =
                    document.getElementById("global-armoury").value === ""
                        ? 0
                        : getVal("global-armoury");

                // Initialize Total Accumulators for individual stats (for the TOTAL column)
                let sumKills = 0;
                let sumElite = 0;
                let sumDeath = 0;
                let sumDamage = 0;

                // --- Calculate for each player and accumulate individual sums for the total column ---
                for (let i = 1; i <= 3; i++) {
                    // Player Inputs
                    const kills = getVal(`p${i}-kills`);
                    const elite = getVal(`p${i}-elite`);
                    const death = getVal(`p${i}-death`);
                    const damage = getVal(`p${i}-damage`);

                    // Accumulate individual stats for the TOTAL column
                    sumKills += kills;
                    sumElite += elite;
                    sumDeath += death;
                    sumDamage += damage;

                    // Calculate Player's Base Score (individual kills + global objective)
                    const playerBaseScore =
                        kills * modKills +
                        elite * modElite +
                        globalObj * modObj;

                    // Calculate Player's Modifier Score (individual death/damage + global geneseed/armoury)
                    const playerModifierScore =
                        death * modDeath +
                        damage * modDamage +
                        globalGene * modGene +
                        globalArmoury * modArmoury;

                    // Calculate Player's Final Score
                    const playerFinalScore = Math.round(
                        playerBaseScore + playerModifierScore,
                    );

                    // Update DOM for Player
                    setTxt(`p${i}-base`, Math.round(playerBaseScore * 10) / 10);
                    setTxt(
                        `p${i}-mod`,
                        parseFloat(playerModifierScore.toFixed(1)),
                    );
                    setTxt(`p${i}-final`, playerFinalScore);
                }

                // --- Calculate and Update Total Column (ensuring global objectives are counted ONCE for the total) ---

                // Update total individual stats
                setTxt("total-kills", sumKills);
                setTxt("total-elite", sumElite);
                setTxt("total-death", sumDeath);
                setTxt("total-damage", sumDamage);

                // Calculate TOTAL Base Score for the squad
                // This is the sum of all individual kill-based scores PLUS the global objective score ONCE
                const totalSquadBaseScore =
                    sumKills * modKills +
                    sumElite * modElite +
                    globalObj * modObj;

                // Calculate TOTAL Modifier Score for the squad
                // This is the sum of all individual death/damage-based scores PLUS the global geneseed/armoury scores ONCE
                const totalSquadModifierScore =
                    sumDeath * modDeath +
                    sumDamage * modDamage +
                    globalGene * modGene +
                    globalArmoury * modArmoury;

                // Calculate TOTAL Final Score for the squad
                const totalSquadFinalScore = Math.round(
                    totalSquadBaseScore + totalSquadModifierScore,
                );

                // Update DOM for Total Column
                setTxt("total-base", Math.round(totalSquadBaseScore * 10) / 10);
                setTxt(
                    "total-mod",
                    parseFloat(totalSquadModifierScore.toFixed(1)),
                );
                setTxt("total-final", totalSquadFinalScore);
            }

            // Function to export table data to CSV
            function exportToCSV() {
                const missionName = getStr("mission-name");
                const missionDifficulty =
                    document.getElementById("mission-difficulty").value; // Get value here

                let filename = "Mission_Debrief_Data";
                if (missionName) {
                    filename = `${missionName.replace(/[^a-zA-Z0-9]/g, "_")}_Debrief_Data`;
                }
                filename += ".csv";

                const table = document.querySelector(".score-table");
                const rows = table.querySelectorAll("tr");
                const csv = [];

                // Add Mission Name and Global Parameters
                csv.push(`Mission Played:,${getStr("mission-name")}`);
                csv.push(`Difficulty:,${missionDifficulty}`); // NEW LINE HERE
                csv.push(
                    `Objective Completion:,${document.getElementById("global-objective").value === "1" ? "Yes" : "No"}`,
                );
                csv.push(
                    `Geneseed Retrieved:,${document.getElementById("global-geneseed").value === "1" ? "Yes" : "No"}`,
                );
                csv.push(`Armoury Data Retrieved:,${getVal("global-armoury")}`);
                csv.push(""); // Empty line for separation

                // Add Modifiers
                csv.push("MODIFIERS,,,,,"); // Header for modifiers row
                csv.push(`Kills:,${getVal("mod-kills")}`);
                csv.push(`Special Kills:,${getVal("mod-elite")}`);
                csv.push(`Death:,${getVal("mod-death")}`);
                csv.push(`Damage:,${getVal("mod-damage")}`);
                csv.push(`Geneseed:,${getVal("mod-gene")}`);
                csv.push(`Armoury:,${getVal("mod-armoury")}`);
                csv.push(`Objective:,${getVal("mod-obj")}`);
                csv.push(""); // Empty line for separation

                // Iterate over table rows
                rows.forEach((row, rowIndex) => {
                    const rowData = [];
                    const cells = row.querySelectorAll("th, td");

                    cells.forEach((cell, cellIndex) => {
                        let cellValue = "";
                        // For input fields in headers (player names)
                        if (
                            rowIndex === 0 &&
                            cell.querySelector('input[type="text"]')
                        ) {
                            cellValue =
                                cell.querySelector('input[type="text"]')
                                    .value ||
                                cell.querySelector('input[type="text"]')
                                    .placeholder;
                        }
                        // For input fields in data cells
                        else if (cell.querySelector('input[type="number"]')) {
                            cellValue = cell.querySelector(
                                'input[type="number"]',
                            ).value;
                        }
                        // For text content
                        else {
                            cellValue = cell.textContent.trim();
                        }
                        rowData.push(`"${cellValue.replace(/"/g, '""')}"`); // Quote and escape double quotes
                    });
                    csv.push(rowData.join(","));
                });

                const csvFile = new Blob([csv.join("\n")], {
                    type: "text/csv;charset=utf-8;",
                });
                const downloadLink = document.createElement("a");
                downloadLink.download = filename;
                downloadLink.href = window.URL.createObjectURL(csvFile);
                downloadLink.style.display = "none";
                document.body.appendChild(downloadLink);
                downloadLink.click();
                document.body.removeChild(downloadLink);
            }

            // Function to save the entire cogitator-frame as PNG (always renders in wide desktop view)
            function saveAsPNG() {
                const element = document.querySelector(".cogitator-frame");
                const body = document.body;
                const html = document.documentElement;

                // Store original styles
                const originalElementWidth = element.style.width;
                const originalElementMaxWidth = element.style.maxWidth;
                const originalElementMinWidth = element.style.minWidth;
                const originalBodyOverflow = body.style.overflow;
                const originalBodyWidth = body.style.width;
                const originalHtmlWidth = html.style.width;
                const originalViewport = document.querySelector(
                    'meta[name="viewport"]',
                );
                const originalViewportContent = originalViewport
                    ? originalViewport.getAttribute("content")
                    : null;

                // Temporarily change viewport to allow wider rendering on mobile
                if (originalViewport) {
                    originalViewport.setAttribute(
                        "content",
                        "width=1200, initial-scale=1.0",
                    );
                }

                // Force wide desktop layout for screenshot - set on all containers
                element.style.width = "1100px";
                element.style.maxWidth = "1100px";
                element.style.minWidth = "1100px";
                body.style.width = "1200px";
                body.style.minWidth = "1200px";
                body.style.overflow = "visible";
                html.style.width = "1200px";
                html.style.minWidth = "1200px";

                // Wait for layout to settle, then capture
                setTimeout(() => {
                    html2canvas(element, {
                        scale: 2,
                        backgroundColor: "#000",
                        useCORS: true,
                        windowWidth: 1200,
                        windowHeight: 1400,
                        scrollX: 0,
                        scrollY: 0,
                        logging: true,
                        allowTaint: false,
                        foreignObjectRendering: false,
                    })
                        .then((canvas) => {
                            // Restore original styles
                            element.style.width = originalElementWidth;
                            element.style.maxWidth = originalElementMaxWidth;
                            element.style.minWidth = originalElementMinWidth;
                            body.style.overflow = originalBodyOverflow;
                            body.style.width = originalBodyWidth;
                            html.style.width = originalHtmlWidth;

                            // Restore viewport
                            if (originalViewport && originalViewportContent) {
                                originalViewport.setAttribute(
                                    "content",
                                    originalViewportContent,
                                );
                            }

                            console.log(
                                "Canvas dimensions:",
                                canvas.width,
                                "x",
                                canvas.height,
                            );

                            const link = document.createElement("a");
                            link.download = "Mission_Debrief_Display.png";
                            link.href = canvas.toDataURL("image/png");
                            link.click();
                        })
                        .catch((err) => {
                            // Restore styles on error too
                            element.style.width = originalElementWidth;
                            element.style.maxWidth = originalElementMaxWidth;
                            element.style.minWidth = originalElementMinWidth;
                            body.style.overflow = originalBodyOverflow;
                            body.style.width = originalBodyWidth;
                            html.style.width = originalHtmlWidth;

                            // Restore viewport
                            if (originalViewport && originalViewportContent) {
                                originalViewport.setAttribute(
                                    "content",
                                    originalViewportContent,
                                );
                            }

                            console.error("PNG export failed:", err);
                            alert(
                                "Failed to capture screenshot. Please try again.",
                            );
                        });
                }, 300); // Give more time for viewport change to take effect
            }

            // Initialize: load saved data and calculate when DOM is ready
            document.addEventListener("DOMContentLoaded", function () {
                loadData();
                calculate();
            });
        </script>

        <!-- Service Worker Registration -->
        <script>
            if ("serviceWorker" in navigator) {
                window.addEventListener("load", () => {
                    navigator.serviceWorker
                        .register("/service-worker.js")
                        .then((registration) => {
                            console.log(
                                "Service Worker registered! Scope:",
                                registration.scope,
                            );
                        })
                        .catch((err) => {
                            console.log(
                                "Service Worker registration failed:",
                                err,
                            );
                        });
                });
            }
        </script>
    </body>
</html>
